# ch02. 객체지향 프로그래밍

### 객체지향 프로그래밍을 하기 위해 집중할 점

1. 어떤 클래스가 필요한지 고민하기 **전에 어떤 객체들이 필요한지 고민하라.** 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화 한것. 따라서 어떤 객체들이 어떤 **상태**와 **행동**을 가지는지 먼저 결정
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체에 일원으로 봐야 한다. 객체를 협력에 참여하는 협력자로 바라보아야 한다.

프로그래머의 역할

- 클래스 작성자
    - 새로운 데이터타입을 프로그램에 추가
- 클라이언트 프로그래머
    - 클래스 작성자가 추가한 데이터 타입을 사용

이 때 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만을 공개하고 나머지는 숨겨야 한다. 이렇게 하면 클라이언트 프로그래머에 대한 영향을 걱정하지 않고 내부 구현을 마음대로 변경할 수 있다. 이를 **구현은닉**이라 한다.

코드의 의존성과 실행시점의 의존성이 서로 다를 수 있다.

- 그 다름이 클 수록 코드를 이해하긴 어려워진다.
- 하지만 그럴 수록 코드는 더 유연해지고 확장 가능해진다.

설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.

반면 유연성을 억제하면 디버깅과 코드의 이해는 쉬워지지만 재사용성과 확장 가능성은 낮아진다.

정답은 없다. 유연성과 가독성 사이에서 고민해야한다.

### 상속과 인터페이스

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다. 결과적으로 자식 클래스는 부모클래스가 수신할 수있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식클래스를 부모클래스와 동일한 타입으로 간주한다.

### 다형성

한 객체(A)가 다른 인스턴스(B)에게 메시지를 전송했을 때, A와 협력하는 객체(C: 이때 C는 B를 상속받음) 에서 오버라이딩한 메서드가 실행되는 것.

코드상에서는 A클래스는 B클래스에게 메시지를 전송하지만 **실행시점**에 실제로 실행 되는 메서드는 A객체와 협력하는 객체의 실제클래스가 무엇인지에 따라 달라진다. 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 다형성이라고 부른다.

다형성을 구현하는 방법은 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일시점이 아닌 실행시점에 바인딩하는 것을 **지연바인딩** 또는 **동적바인딩** 이라고 한다.

### 합성

Movie는 요금을 계산하기 위해 DiscountPolicy(인터페이스)의 코드를 재사용한다(calculateDiscountAmount()). 이처럼 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 한다.

합성은 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 **캡슐화** 할 수 있다. 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용해야 한다. (인터페이스를 구현후 상속, 그 인터페이스를 합성하여 사용)